
#include <iostream>
#include <vector>
using namespace std;

//给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

//示例:

// 输入: [4, 6, 7, 7]
// 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
// 说明:

// 1、给定数组的长度不会超过15。
// 2、数组中的整数范围是?[-100,100]。
// 3、给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。
//
// [4,2,7,7]
//                  []
//         4   2     7   7
//     2 7 7   7 7   7      无可选


class Solution {
public:
    vector<vector<int>> ret;
    vector<int> tmp;
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return ret;
    }
    // 回溯算法
    // 本题主要考虑如何去重
    // 在递归的同一层避免出现遍历同一个，用set记录本层递归是否使用当前值

    void backtracking(vector<int> nums, int begin){
        // if(begin >= nums.size()) return;
        if(tmp.size() >= 2){
            ret.push_back(tmp);
        }
        // std::set<int> s; 
        vector<int> s(201, 0);  //用vector代替set
        for(int i = begin; i < nums.size(); i++){
            if(tmp.size() > 0 && nums[i] < tmp[tmp.size() - 1] || s[nums[i] + 100] == 1) continue; 
            tmp.push_back(nums[i]);
            s[nums[i] + 100] = 1;
            // s.insert(nums[i]);
            backtracking(nums, i + 1);
            tmp.pop_back();
        }
    }

};

